#### 数据库

- 事务的特性 ACID

  >  所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。
  >
  >  ACID 是 Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和 Durability（持久性）。
  >
  >  隔离性：事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，**事务不会查看到中间状态的数据**。
  >
  >  原子性：SQL 都成功或都撤销
  >
  >  一致性：不能破坏数据的完整和逻辑。
  >
  >  持久性：事务成功，更新必须永久保存。
  >
  >  数据库管理系统采**用日志来保证事务的原子性、一致性和持久性**。数据库管理系统**采用锁机制来实现事务的隔离性**。
  >
  >  [Link](http://www.cnblogs.com/younes/archive/2010/09/09/1822436.html)

#### 分布式系统

> 分布式领域[CAP理论](http://www.hollischuang.com/archives/666)告诉我们，任何一个分布式系统都无法同时满足Consistency(一致性),Availability(可用性), Partition tolerance(分区容错性) 这三个基本需求。最多只能满足其中两项。

- 一致性

  > 我们所说的分布式一致性问题通常指的是**数据一致性**问题。在分布式系统中，数据一致性往往指的是由于**数据的复制**，**不同数据节点**中的数据内容是否**完整并且相同**。一个系统如果想保证数据一致性很有**可能影响其性能**。因为并发的写请求需要在前一个写请求结束之后才能进行 **(排队)** 。
  >
  > 一致性模型：
  >
  > - 强一致性：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。
  > - 弱一致性：系统并不保证后续进程或者线程的访问都会返回最新的更新过的值。
  > - 最终一致性：弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。
  >
  > [Link](http://www.hollischuang.com/archives/663)

- 分布式一致性协议/算法

  > **分布式事务**是指会涉及到操作多个数据库的事务。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）。
  >
  > - **二阶段提交（2PC）**：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。所谓的两个阶段是指：第一阶段：**准备阶段(投票阶段)**和第二阶段：**提交阶段（执行阶段）**。
  >
  >   缺点：1、**同步阻塞问题**；2、**单点故障导致阻塞**。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去；3、**数据不一致**。协调者故障，只向部分节点发送 commit 命令；
  >
  > - **三阶段提交（3PC）**：引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。
  >
  >   ```
  >   在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。
  >   ```
  >   相对于2PC，3PC主要解决的单点故障问题，并减少阻塞。但是这种机制也会导致数据一致性问题。
  >
  > [Link](http://www.hollischuang.com/archives/681)
  >
  > - **Paxos 算法**：主要解决的问题就是如何保证分布式系统中各个节点都能执行一个相同的操作序列。
  >
  >   1、在整个提议和投票过程中，主要的角色就是“提议者”（向“接受者”提出提议）和“接受者”（收到“提议者”的提议后，向“提议者”表达自己的意见）。
  >
  >   2、整个算法的大致过程为：
  >   第一阶段：明确哪个“提议者”是意见领袖有权提出提议，未来，“接受者”们就主要处理这个“提议者”的提议了**（这样，也可以在提出提议时就尽量让意见统一，谋求尽早形成多数派）。**
  >   第二阶段：由上阶段选出的意见领袖提出提议，“接受者”反馈意见。如果多数“接受者”接受了一个提议，那么提议就通过了。（“提议者”在贿选的时候，发现“接受者”已经接受过前面意见领袖的提议了，即便“提议者”贿选成功，也会默默的把自己的提议改为前面意见领袖的提议。）
  >
  >   [Link1](https://www.zhihu.com/question/19787937/answer/107750652) [Link2](http://www.hollischuang.com/archives/693) [Link3](https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95) [Link4](https://coolshell.cn/articles/10910.html)
#### 操作系统

- 同步与异步

  > 所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个**调用**的结果。
  >
  > 而异步则是相反，**调用在发出之后**，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过**回调函数**处理这个调用。
  >
  > [Link](https://www.zhihu.com/question/19732473/answer/20851256)

- 阻塞与非阻塞

  > 阻塞和非阻塞关注的是**程序在等待调用结果**（消息，返回值）时的状态。
  >
  > 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
  > 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程（不会被挂起）。
  >
  > [Link](https://www.zhihu.com/question/19732473/answer/20851256)

- buffer 与 cache 的区别

  > Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。
  >
  > Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。
  >
  > [Link](http://blog.sina.com.cn/s/blog_93dc666c0101cb35.html)
  >

- 进程间通信

  > - 管道/匿名管道 (pipe)；命名管道 (FIFO)
  >
  >   半双工，单向，具有亲缘关系，内核缓冲区，无格式字节流，存在于内存中；无需具有亲缘关系，存在于文件系统中，内容存放在内存中。
  >
  > - 信号 (Signal)
  >
  >   信号是软件层次上对中断机制的一种模拟，是一种异步通信方式。
  >
  >   - 硬件来源：用户按键输入`Ctrl+C`退出、硬件异常如无效的存储访问等。
  >   - 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。
  >
  > - 消息队列 (Message)
  >
  >   消息队列是消息的链表，具有特定的格式，可随机查询，无需等待写入
  >
  > - 共享内存 (share memory)
  >
  >   使得多个进程可以可以直接读写同一块内存空间，是最快的可用 IPC 形式。需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。
  >
  > - 信号量 (semaphore)
  >
  >   信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。信号量值的测试及减 1 操作应当是原子操作。
  >
  >   互斥量用于线程的互斥，信号量用于线程的同步。
  >
  > - 套接字 (socket)
  >
  >   客户/ 服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。
  >
  >   套接字是支持 TCP/IP 的网络通信的基本操作单元。
  >
  >   套接字的特性由3个属性确定，它们分别是：域(AF_INET, AF_UNIX) 、端口号、协议类型。
  >
  > [Link](https://www.jianshu.com/p/c1015f5ffa74)

- 信号量与互斥量的区别

  > 互斥量用于线程的互斥，信号量用于线程的同步。
  >
  > **互斥：**是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
  >
  > **同步：**是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
  >
  > 信号量可以实现多个同类资源的多线程互斥和同步。互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。
  >
  > [Link](https://www.jianshu.com/p/c1015f5ffa74)

- 进程与线程的区别

  > - 一个程序至少有一个进程,一个进程至少有一个线程；
  > - 进程是系统进行资源分配和调度的一个独立单位，线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
  > - 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；
  > - 一个进程崩溃后，在保护模式下不会对其它进程产生影响，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
  >
  > [Link](http://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html)

#### 网络编程

- TCP 三次握手四次挥手

  > 三次握手：前两次握手为了彼此间能通信，第三次握手防止服务器一直等待。第一次握手重发的请求可能在挥手后被服务器接收，服务器第二次握手后就处于等待状态。
  >
  > 四次挥手：TCP是全双工模式。都需要告诉彼此没有数据发送并且都需要得到回复。四次挥手TIME_WAIT保持2MSL(最大报文段生存时间)原因，主要是防止最后一个ack丢失。
  >
  > [Link](https://github.com/jawil/blog/issues/14)

- HTTP 连接

  > **HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。**从建立连接到关闭连接的过程称为“一次连接”。
  > 1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
  >
  > 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。
  >
  > [Link](https://github.com/jawil/blog/issues/14)

- Socket

  > **应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。**
  >
  > 包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
  >
  > 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
  >
  > [Link](https://github.com/jawil/blog/issues/14)

- 七/五层模型

  > 七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层；
  >
  > 五层：物理层，链路层，网络层，传输层，应用层。

- ​

#### Linux

- linux 下查找哪个文件占用空间最大的方法

  使用 du 命令 + sort 命令

  `du : 计算出单个文件或者文件夹的磁盘空间占用.`

  `sort : 对文件行或者标准输出行记录排序后输出.`

  `grep: 该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来`

  `ps: 用于将某个时间点的进程运行情况选取下来并输出 `

  `kill: 该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号 `

  `file: 该命令用于判断接在file命令后的文件的基本数据`

  `cat: 该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用`

  `chmod: 该命令用于改变文件的权限`

  `time:该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可`

  [Link](http://blog.csdn.net/ljianhui/article/details/11100625)

#### 算法

- [求二叉树中两个节点的最低公共祖先节点](http://blog.csdn.net/wenqiang1208/article/details/64152061)

- ​

#### C++ 特性

- 面向对象的了解

  > 面向对象编程注重的是：**1）数据和其行为的打包封装，2）程序的接口和实现的解耦**。[Link](https://coolshell.cn/articles/8745.html)

  > 面向对象是相对于面向过程而言的。面向过程语言是一种基于**功能分析**的、以**算法**为中心的程序设计方法；而面向对象是一种基于**结构分析**的、以**数据**为中心的程序设计思想。
  >
  > 从面向过程的角度看，类就是一个特殊的数据结构，它就好像是我们C语言中的结构体;从面向对象的角度看，类就是具有相同属性和方法的对象的集合。
  >
  > 面向对象有三大特性：封装、继承、多态。
  >
  > - **封装，**就是指隐藏对象的实现细节，给外界提供公共的方法来访问。
  >
  >
  > - **继承**，子类可以继承父类的公共属性和方法，子类永远没法继承到父类的私有属性和方法。
  > - **多态，**就是同一个实现接口，对不同的实例而执行不同的操作。
  >
  > [Link](https://my.oschina.net/shaw1688/blog/601142)

- 多态实现原理

  > 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。
  >
  > C++的多态性是通过动态绑定技术来实现的。
  >
  > [Link](http://blog.csdn.net/tujiaw/article/details/6753498)

  > 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。
  >
  > 多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。
  >
  > [Link](https://www.jianshu.com/p/3a404ab34936)

- ​


#### Python 特性

#### Git

- 分区

  > 分为：工作区，版本库，版本库包含暂存区、分支以及分支指针。
  >
  > 第一步是用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区；
  >
  > 第二步是用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支。

#### 自我介绍

