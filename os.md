#### 分布式系统

> 分布式领域[CAP理论](http://www.hollischuang.com/archives/666)告诉我们，任何一个分布式系统都无法同时满足Consistency(一致性),Availability(可用性), Partition tolerance(分区容错性) 这三个基本需求。最多只能满足其中两项。

##### 一致性

> 我们所说的分布式一致性问题通常指的是**数据一致性**问题。在分布式系统中，数据一致性往往指的是由于**数据的复制**，**不同数据节点**中的数据内容是否**完整并且相同**。一个系统如果想保证数据一致性很有**可能影响其性能**。因为并发的写请求需要在前一个写请求结束之后才能进行 **(排队)** 。
>
> >  一致性模型：
> >
> > - 强一致性：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。
> > - 弱一致性：系统并不保证后续进程或者线程的访问都会返回最新的更新过的值。
> > - 最终一致性：弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。
> >
> >  [Link](http://www.hollischuang.com/archives/663)

##### 分布式一致性协议/算法

> **分布式事务**是指会涉及到操作多个数据库的事务。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）。
>
> > - **二阶段提交（2PC）**：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。所谓的两个阶段是指：第一阶段：**准备阶段(投票阶段)**和第二阶段：**提交阶段（执行阶段）**。
> >
> >   缺点：1、**同步阻塞问题**；2、**单点故障导致阻塞**。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去；3、**数据不一致**。协调者故障，只向部分节点发送 commit 命令；
> >
> > - **三阶段提交（3PC）**：引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。
> >
> >   ```
> >   在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。
> >   ```
> >
> >   相对于2PC，3PC主要解决的单点故障问题，并减少阻塞。但是这种机制也会导致数据一致性问题。
> >
> >  [Link](http://www.hollischuang.com/archives/681)
> >
> > - **Paxos 算法**：主要解决的问题就是如何保证分布式系统中各个节点都能执行一个相同的操作序列。
> >
> >   1、在整个提议和投票过程中，主要的角色就是“提议者”（向“接受者”提出提议）和“接受者”（收到“提议者”的提议后，向“提议者”表达自己的意见）。
> >
> >   2、整个算法的大致过程为：
> >   第一阶段：明确哪个“提议者”是意见领袖有权提出提议，未来，“接受者”们就主要处理这个“提议者”的提议了**（这样，也可以在提出提议时就尽量让意见统一，谋求尽早形成多数派）。**
> >   第二阶段：由上阶段选出的意见领袖提出提议，“接受者”反馈意见。如果多数“接受者”接受了一个提议，那么提议就通过了。（“提议者”在贿选的时候，发现“接受者”已经接受过前面意见领袖的提议了，即便“提议者”贿选成功，也会默默的把自己的提议改为前面意见领袖的提议。）
> >
> >   [Link1](https://www.zhihu.com/question/19787937/answer/107750652) [Link2](http://www.hollischuang.com/archives/693) [Link3](https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95) [Link4](https://coolshell.cn/articles/10910.html)

##### 可用性

> 即服务一直可用，而且是正常响应时间。
>
> >  好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。

##### 分区容错性

> 即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

  [Link](http://www.hollischuang.com/archives/666)

#### 操作系统

##### 同步与异步

> 所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个**调用**的结果。
>
> >  而异步则是相反，**调用在发出之后**，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过**回调函数**处理这个调用。
> >
> >  [Link](https://www.zhihu.com/question/19732473/answer/20851256)

##### 阻塞与非阻塞

> 阻塞和非阻塞关注的是**程序在等待调用结果**（消息，返回值）时的状态。
>
> >  阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
> >  非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程（不会被挂起）。
> >
> >  [Link](https://www.zhihu.com/question/19732473/answer/20851256)

##### buffer 与 cache 的区别

> Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。
>
> >  Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。
> >
> >  [Link](http://blog.sina.com.cn/s/blog_93dc666c0101cb35.html)

##### 进程间通信

> - 管道/匿名管道 (pipe)；命名管道 (FIFO)
>
> >    半双工，单向，具有亲缘关系，内核缓冲区，无格式字节流，存在于内存中；无需具有亲缘关系，存在于文件系统中，内容存放在内存中。
> >
> > - 信号 (Signal)
> >
> >   信号是软件层次上对中断机制的一种模拟，是一种异步通信方式。
> >
> >   - 硬件来源：用户按键输入`Ctrl+C`退出、硬件异常如无效的存储访问等。
> >   - 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。
> >
> > - 消息队列 (Message)
> >
> >   消息队列是消息的链表，具有特定的格式，可随机查询，无需等待写入
> >
> > - 共享内存 (share memory)
> >
> >   使得多个进程可以可以直接读写同一块内存空间，是最快的可用 IPC 形式。需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。
> >
> > - 信号量 (semaphore)
> >
> >   信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。信号量值的测试及减 1 操作应当是原子操作。
> >
> >   互斥量用于线程的互斥，信号量用于线程的同步。
> >
> > - 套接字 (socket)
> >
> >   客户/ 服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。
> >
> >   套接字是支持 TCP/IP 的网络通信的基本操作单元。
> >
> >   套接字的特性由3个属性确定，它们分别是：域(AF_INET, AF_UNIX) 、端口号、协议类型。
> >
> >  [Link](https://www.jianshu.com/p/c1015f5ffa74) [Demo](https://songlee24.github.io/2015/04/21/linux-IPC/)

##### 信号量与互斥量的区别

> 互斥量用于线程的互斥，信号量用于线程的同步。
>
> >  **互斥：**是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
> >
> >  **同步：**是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
> >
> >  信号量可以实现多个同类资源的多线程互斥和同步。互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。
> >
> >  [Link](https://www.jianshu.com/p/c1015f5ffa74)

##### 进程与线程的区别

> - 一个程序至少有一个进程,一个进程至少有一个线程；
>
> > - 进程是系统进行资源分配和调度的一个独立单位，线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
> > - 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；
> > - 一个进程崩溃后，在保护模式下不会对其它进程产生影响，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
> >
> > [Link](http://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html)

> 分点回答
>
> > - 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
> > - 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。
> > - 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
> > - 通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。
> >   [Link](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3-%E5%8C%BA%E5%88%AB)

##### fork

> 如果进程需要启动另一个程序的可执行文件，它需要先Fork来创建一个自身的副本。然后由该副本即“[子进程](https://zh.wikipedia.org/wiki/%E5%AD%90%E8%BF%9B%E7%A8%8B)”调用[exec](https://zh.wikipedia.org/w/index.php?title=Exec&action=edit&redlink=1)系统调用，用其他程序覆盖自身：停止执行自己之前的程序并执行其他程序。

- fork 之后，子进程的下一条语句与父进程的下一条语句一样。
- 通过检查 fork 返回值来判断是子进程还是父进程。
  - 在父进程中，fork返回新创建子进程的进程ID；
  - 在子进程中，fork返回0；
  - 如果出现错误，fork返回一个负值；

##### 线程池的实现

  多线程进程：每个线程执行的都是进程代码的某个片段啊。

- 当线程池的线程刚创建时，让他们进入阻塞状态：等待某个任务的到来。 如果任务来了，那就好办，唤醒其中一个线程，让它拿到任务去执行即可。

- BlockingQueue：一个线程调用它的take()方法取数据时， 如果这个Queue中没有数据，该线程会阻塞；同样，一个线程调用它的put方法放数据时，如果Queue满了， 也会阻塞。

  [Link](https://mp.weixin.qq.com/s/fzIsN8DrLUj0NbcJiD6xSw) [实现](http://www.cppblog.com/Chosen/archive/2013/10/07/203568.html)

##### 线程间通信与同步

  通信方式：

- 使用全局变量，全局变量最好声明为 volatile。 volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，而不是使用已经存在寄存器中的值。[Link](https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html)

- 使用消息实现通信。

  - 使用事件类实现线程间通信。

  同步方式：

  - 条件变量：利用线程间共享的全局变量进行同步的一种机制。条件变量上的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。
  - 信号量（semaphore）：如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。
  - 互斥量（mutex）： 通过锁机制实现线程间的同步。同一时刻只允许一个线程执行一个关键部分的代码。

  [Link](https://www.jianshu.com/p/9218692cb209)

##### 多线程实践

- lambda 表达式启动线程：`thread t([i]{cout << i << endl;});`

- 重载了 () 运算符的类 

  [Link](https://www.cnblogs.com/wangguchangqing/p/6134635.html)

##### 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 

- 批处理系统，批处理系统没有太多的用户操作 ，在该系统中，调度算法目标是保证吞吐量和周转时间 。

  非抢占式：先来先服务 FCFS；短作业优先 SJF；

  抢占式：最短剩余时间有限 SRTN。

- 交互式系统：交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 

  时间片轮转 + FCFS；优先级调度；多级反馈队列；

- 实时系统

  要求一个请求在一个确定时间内得到响应。 

##### 进程同步

- 经典同步问题
  - 生产者-消费者问题：使用一个缓冲区来保存物品 ，因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 使用互斥量 + 信号量的方法实现。也可用管程实现。
  - 读者-写者问题：允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 使用两个互斥量对读写进行控制。
  - 哲学家进餐问题：死锁。
    - 只有在两个邻居都没有进餐的情况下才允许进餐。
    - 必须同时拿起左右两根筷子；
- 同步方法
  - 信号量：是一个整型变量 。可以对其执行 down 和 up 操作，需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断 。信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex）。
  - 管程： 管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。进程只能互斥得使用管程，即当一个进程使用管程时，另一个进程必须等待。当一个进程使用完管程后，它必须释放管程并唤醒等待管程的某一个进程。

##### 内存管理

- 虚拟内存

  操作系统将内存抽象成地址空间 ，每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。 

- 分页系统地址映射

  - 内存管理单元（MMU）：管理着地址空间和物理内存的转换。
  - 页表（Page table）：页（地址空间）和页框（物理内存空间）的映射表。

- 页面置换算法

  - 最佳 Optimal

    所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 

  - 先进先出 FIFO

    所选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

  - 第二次机会算法

    第二次机会算法就是寻找一个最近的时钟间隔以来没有被访问过的页面。 

  - 时钟 Clock

    第二次机会算法的循环队列模式，不再从队列头开始查找，而是从当前指针指向开始查找。

  - 最近未使用 Not Recently Used

    系统为毎一页面设置了两个状态位。 当页面被访问 (读或写) 时设置 R 位; 当页面 (即修改页面) 被写入时设置 M 位。 NRU 算法随机地从状态位编号最小的非空类中挑选一个页面淘汰之。 

  - 最近最久未使用 Least Recently Used

- 分段

  程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。 

  段页式：为了进行地址转换，系统为每个作业建立一个段表，并且要为该作业段表中的每一个段建立一个页表。 

[Link](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E5%9B%9B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86)

##### 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴旋转磁盘，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

先来先服务 FCFS；最短寻道时间有限 SSTF；电梯算法 SCAN。

[Link](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)

##### 死锁

- 必要条件

  - 互斥，占有和等待，不可抢占，环路等待。

- 鸵鸟策略

  因为解决死锁问题的代价很高 ，因此大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 

- 死锁预防

  在程序运行之前预防发生死锁。 破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。 [Link](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2)

- 死锁避免

  在程序运行时避免发生死锁。 

  - 安全状态

    存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 

  - 单个资源的银行家算法

    算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。（与多个资源的死锁检测类似）

  - 多个资源的银行家算法

    [算法](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#4-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D)

- 死锁检测与死锁恢复

  - 每种类型一个资源的死锁检测 

    通过检测有向图是否存在环来实现 。

  - 每种类型多个资源的死锁检测

    与多个资源的银行家算法类似

  - 死锁恢复

    - 利用抢占恢复， 利用回滚恢复，通过杀死进程恢复

#### Linux

##### linux 下查找哪个文件占用空间最大的方法

  使用 du 命令 + sort 命令

  `du : 计算出单个文件或者文件夹的磁盘空间占用.`

  `sort : 对文件行或者标准输出行记录排序后输出.`

  `grep: 该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来`

  `ps: 用于将某个时间点的进程运行情况选取下来并输出 `

  `kill: 该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号 `

  `file: 该命令用于判断接在file命令后的文件的基本数据`

  `cat: 该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用`

  `chmod: 该命令用于改变文件的权限`

  `time:该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可`

`touch:修改文件的访问和修改时间`

  [Link](http://blog.csdn.net/ljianhui/article/details/11100625)

##### shell 统计文件中单词出现的次数

  `wc -c 统计字节数，-l 统计行数，-w 统计字数，-m 统计字符数 `

  `grep cout hello.cpp | wc -l # 统计出现 cout 的行数`

  `grep -o cout hello.cpp | wc -l # 统计出现 cout 的次数`

##### 查看某个端口是否被占用

```bash
$ sudo lsof -i # 查看端口占用情况
$ sudo lsof -i:21 # 查看 21 号端口是否被占用
$ netstat -apn | grep 21 
```

##### 找出出现次数最多的前三个 ip 及次数

`sort ip.txt | uniq -c | sort -rn | head -n 3`

sort 按 ASCII 码排序 -n 依照数值大小排序 -r 反向

uniq -c 统计相邻的不重复项

##### umask

> umask 是设置系统创建文件时的默认权限**补码**，默认权限是 666 ，umask设为 244 ，则创建文件的权限为 422 .