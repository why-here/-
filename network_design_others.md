#### 网络编程

[socket疑问解答](https://www.cnblogs.com/kex1n/p/6501977.html)

##### C10K / C1000K 问题

- 最初服务器，新到来一个TCP连接，就需要分配一个进程。如果有10K个Client 就需要创建 1W 个进程。但单机无法承受。
- 解决方案：
  - 每个连接分配一个独立的线程/进程
  - 同一个线程/进程同时处理多个连接（IO 多路复用）[Link](https://blog.csdn.net/yeasy/article/details/43152115)
- C10M ：当连接很多时，首先需要大量的进程/线程来做事。 会有频繁的进程切换。通过协程模型进行解决。一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换。 

**问题** ：

- Linux 操作系统默认最大打开文件数为 10 万左右，可以修改。并且默认限制每个进程最多只能打开 1024 个文件。同样可以修改。
- 百万个 fd 占用 4M / 8M 。实际测试什么数据也不发送也不接收，操作系统用了 200M(大致)内存来维护这 10 万个连接!  如果是百万连接就需要占用 2GB 内存。
- 应用程序维持百万个空闲的连接, 只会占用操作系统的内存, 通过 ps 命令查看可知, 应用程序本身几乎不占用内存. 
- 百万连接的吞吐量。 20%活跃并以 1KB 速率算，需要 1.6Gbps。

##### TCP 三次握手四次挥手

> 三次握手：前两次握手为了彼此间能通信，第三次握手防止服务器一直等待。第一次握手重发的请求可能在挥手后被服务器接收，服务器第二次握手后就处于等待状态。
>
> 四次挥手：TCP是全双工模式。都需要告诉彼此没有数据发送并且都需要得到回复。四次挥手TIME_WAIT保持2MSL(最大报文段生存时间)原因，主要是防止最后一个ack丢失。
>
> [Link](https://github.com/jawil/blog/issues/14)

##### HTTP 连接

> **HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。**从建立连接到关闭连接的过程称为“一次连接”。
>
> > 1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
> >
> > 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。
> >
> > [Link](https://github.com/jawil/blog/issues/14)

##### Socket

> **应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。**
>
> >  包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
> >
> >  套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
> >
> >  [Link](https://github.com/jawil/blog/issues/14) [Confuse](https://www.cnblogs.com/kex1n/p/6501977.html)

##### 七/五层模型

> 七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层；
>
> >  五层：物理层，链路层，网络层，传输层，应用层。

> > 

#### 设计模式

[写给人看的设计模式](https://pushmind.org/2017/07/31/design-patterns-for-humans/)

##### 设计模式的类型

- 创建型
- 结构型
- 行为型

##### 创建型设计模式

简言之:

> 创建型模式, 是针对如何创建对象的解决方案。简单工厂；工厂方法；抽象工厂；生成器；原型；单例。

1. 简单工厂

> 简单工厂为用户提供了一个实例, 而隐藏了具体的实例化逻辑. 给我造个门

1. 工厂方法

> 一种将实例化逻辑委托给**子类**的方法. 给我造个**铁**门

1. 抽象工厂

> 管理各自独立却又互相依赖的一批工厂（门，匠...）, 而不关心各自的细节. 给我造个**木**门，再给我配个**木**匠。

1. 生成器

> 当创建对象有好多种选项时，导致构造函数的参数列表失控。生成器模式的本质, 就是将构造函数中的参数列表方法化。函数式编程中对该问题的解决方式是: 柯里化, 其本质与生成器模式是一样的。

1. 原型

> 允许你拷贝一份已有对象, 并根据需求改造之。 

1. 单例

> 确保一个特定类的一个对象, 只能创建一次。创造单例, 要确保构造函数私有化, 拷贝构造, 拷贝赋值应该禁用。创建一个静态变量来存此单例。

##### 结构性设计模式

简言之：

> 结构型模式重点关注对象组合, 换句话说, 实体如何互相调用. 

1. 适配器

> 包装一个对象, 让本不兼容其他类的对象变得可兼容。在中间加一层的方式来解决。为了兼容。

1. 桥接

> 优先考虑组合而非继承. 将实现细节从层次结构中, 剥离并独立成另一套层次结构。桥接模式本质上是一种拆分。

1. 组成

> 组合模式让客户以统一的方式对待各个独立的对象。其核心就是多态特性的体现。

1. 装饰

> 装饰模式将对象包装在装饰类对象中, 从而在运行时动态改变该对象的行为。装饰的是对象自身, 且支持重复装饰。

1. 外观

> 外观模式为复杂的子系统提供了一个简单接口。用的依然是”多加一层”的思想, 通过封装的方式来实现。为了封装。

1. 享元

> 通常以最小的存储用量或计算成本为代价, 共享给尽可能多的相似对象。享元模式的本质就是最基本的缓存思想。

1. 代理

> 使用代理模式, 一个类会表现出另一个类的功能。依然体现了加一层的思想。为了增加功能。

##### 行为型设计模式

简言之：

> 关注对象间的责任分配. 它们与结构模式最大的不同在于: 它们不仅仅指定结构, 还概述了结构之间消息传递/通讯的模式. 

1. 责任链

> 它有助于建立一条对象链. 请求会从一端开始, 依次访问对象, 直到找到合适的处理程序. 就像根据付款额选择一串付款方式中的一个。

1. 命令

> 允许你将操作封装在对象中. 这种模式背后的核心思想是分离客户与接收者. 你(客户)用遥控器(调用者)来切换(命令)电视(接收者)节目. 命令模式本质上, 是对消息协议的一种抽象, 而用的手法是回调。 提出要求的是客户, 执行要求的是厨师, 而连接两者的是服务员, 但真正连接者是消息的接口, 这个就是命令. 

1. 迭代器

> 它呈现了一种访问对象元素, 却不暴露底层方法的方式.

1. 中介者

> 中介者模式增加了一个第三方对象(中介者)来控制两个对象(同事)间的交互. 有助于对彼此通信的解耦, 毕竟他们并不需要关心对方的实现细节.

1. 备忘录

> 备忘录模式会抓取并储存对象的当前状态, 之后可便捷的恢复出来. 就是对缓存这个行为的对象化. 

1. 观察者

> 定义对象间的依赖关系, 以至于一个对象的状态改变, 依赖它的对象们都会收到通知. 被称为发布-订阅模式. 但无论叫什么, 其实本质都是注入+回调. 

1. 访问者

> 访问者模式允许你为对象们增加更多的操作, 却不必修改它们. 其实本质依然是注入-回调模式. 想用一个统一的接口, 去迭代的调用这些不同的方法，是一种对调用的抽象。

1. 策略

> 策略模式允许你根据实际情况切换算法或策略. 本质依然是注入+多态

1. 状态

> 它让你在状态改变的同时, 也改变类的行为。例如, 你选择了加粗, 后续的字都会是粗的, 同样的, 选择了斜体, 后续都会是斜体. 本质依然是注入+多态。

1. 模板方法

> 模板方法定义了如何执行某种算法的框架, 但将具体实现延迟到子类. 模板方法基本就是多态的集中体现. 只不过将所有多态方法集中到一个公共接口中. 