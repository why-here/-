#### 网络编程

[socket疑问解答](https://www.cnblogs.com/kex1n/p/6501977.html)

##### select / poll / epoll 区别

文件描述符限制：

- select / poll / epoll 都有进程的文件描述符数量的限制，默认 1024 个。可以通过 `ulimit -n` 临时修改，或修改 `/etc/security/limits.conf` 文件。其次，系统也有总的文件描述符的数量限制，默认 10 万个左右。参考 [ideawu-C1000k](http://www.ideawu.net/blog/archives/740.html) 。
- 其次 select 的 fd_set 也有范围，fd_set 是一个总共 1024 bit 的数组，最多只能标记 1024 个连接，select 能处理三种类型的 IO 事件。因此，突破了进程 1024 文件描述符的限制后，select 最多能监视 1024 * 3 个文件描述符。

select ：

- 优点：可移植性好；超时值提供更好的精度：微秒，poll 是毫秒。
- 缺点：fd_set 有大小限制；需要在内核态和用户态间反复复制 fd_set；有 IO 事件时，需要遍历 fd_set 找到对应的 fd；每次都需要重新设置 fd_set；需要计算得到最大的 fd 。

poll ：

- 优点：通过 pollfd 结构体数组传递监测的 fd 和 event ，没有额外 fd 数量限制；pollfd 只需要被初始化一次，无需重复设置。
- 缺点：pollfd 数组仍需要在用户态和内核态间复制；仍需要遍历整个 pollfd 数组。

epoll：

- 优点：适合需要操作大量 fd 的程序，fd 只在内核态和用户态直接拷贝一次；同时无需遍历所有 fd，只需遍历传入的固定大小的 epoll_event 数组。支持水平触发（LT）和边缘触发（ET）。
- LT 和 ET 的区别：ET 只有在状态变换才会返回该事件，LT 只要满足条件就能返回该事件。如监测一个 PIPE ，当第一次有数据可读时，ET or LT 都会返回该事件；如果程序只读取部分数据，并且没有新数据被写到 PIPE 中，ET 下一次就不会返回，而 LT 会返回。[epoll wiki](https://en.wikipedia.org/wiki/Epoll) 

[Link](https://blog.csdn.net/lixungogogo/article/details/52226501) [Linux IO](https://segmentfault.com/a/1190000003063859)

##### TCP/UDP 区别

- TCP 是面向连接，UDP 是无连接，即发送数据之前不需要建立连接；而 TCP 建立连接和断开连接分别需要三次握手和四次挥手；
- TCP 是字节流协议，UDP 是报文协议。TCP 需要上层限定消息的边界。否则会出现“粘包”，“拆包”现象。
- TCP 提供可靠的数据传输，UDP 不保证可靠交付；TCP 保证字节流无差错，不丢失，不重复且按序到达。
- TCP 有流量控制和拥塞控制，保证传输的有效性。
- TCP 连接是点到点的传输，UDP 支持一对一，一对多，多对一和多对多的交互通信。
- TCP 首部开销 20 字节，UDP 的首部开销小，只有 8 个字节。

[Link](https://blog.csdn.net/Li_Ning_/article/details/52117463)

##### Time_Wait 状态的作用

- Time_Wait 状态将保持 2 MSL（最大段生存时间），保证被动关闭的一方能收到最后发出去的 ACK。若没有 Time_Wait，被动关闭一方没有收到 ACK，重发 Fin，将会收到 RST 信令。
-  Time_Wait 保持 2 MSL 时长，还能保证其发送的重复分组在网络中消失。避免旧分组被当成新连接的数据而被接收。

##### 避免大量 Time_Wait 状态的连接

- net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将 TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； 
- net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中 TIME-WAIT sockets的快速回收，默认为0，表示关闭。 
- net.ipv4.tcp_fin_timeout = 30 修改系統默认的 TIMEOUT 时间，改为 30s
- net.ipv4.tcp_max_tw_buckets 控制并发的 TIME_WAIT 的数量，默认值是 180000，如果超限，那么，系统会把多的给 destory 掉。
- 不主动断开连接；

[Link](http://coolnull.com/3605.html) [Link](https://coolshell.cn/articles/11564.html)

##### SYN 超时以及 SYN 攻击

- 服务器收到 SYN，但是没收到 ACK。连接处于中间状态，服务器会重发 SYN-ACK，Linux 默认重发 5 次，每次重发时间翻翻，1s，2s，4s，8s，16s，第 5 次发出后还要等 32s 才知道第 5 次也超时了，总共 63s。
- 一些恶意的人就为此制造了 SYN Flood 攻击——给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 SYN 连接的队列耗尽，让正常的连接请求不能处理。
- net.ipv4.tcp_syncookies = 1 表示开启 SYN Cookies。当出现 SYN 等待队列溢出时，启用 cookies 来处理可防范少量 SYN 攻击，默认为 0 表示关闭；
- 调整三个 TCP 参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大 SYN 连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。

##### 分组序号初始化

- 每 4 微秒对 ISN 做加一操作，直到超过 2^32，又从 0 开始。这样，一个 ISN 的周期大约是4.55 个小时。
- 当网络断开重连后，避免旧分组被当成新分组而被接收。

##### C10K / C1000K 问题

- 最初服务器，新到来一个TCP连接，就需要分配一个进程。如果有10K个Client 就需要创建 1W 个进程。但单机无法承受。
- 解决方案：
  - 每个连接分配一个独立的线程/进程
  - 同一个线程/进程同时处理多个连接（IO 多路复用）[Link](https://blog.csdn.net/yeasy/article/details/43152115)
- C10M ：当连接很多时，首先需要大量的进程/线程来做事。 会有频繁的进程切换。通过协程模型进行解决。一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换。 

**问题** ：

- Linux 操作系统默认最大打开文件数为 10 万左右，可以修改。并且默认限制每个进程最多只能打开 1024 个文件。同样可以修改。
- 百万个 fd 占用 4M / 8M 。实际测试什么数据也不发送也不接收，操作系统用了 200M(大致)内存来维护这 10 万个连接!  如果是百万连接就需要占用 2GB 内存。
- 应用程序维持百万个空闲的连接, 只会占用操作系统的内存, 通过 ps 命令查看可知, 应用程序本身几乎不占用内存. 
- 百万连接的吞吐量。 20%活跃并以 1KB 速率算，需要 1.6Gbps。

##### TCP 三次握手四次挥手

> 三次握手：前两次握手为了彼此间能通信，第三次握手防止服务器一直等待。第一次握手重发的请求可能在挥手后被服务器接收，服务器第二次握手后就处于等待状态。
>
> 四次挥手：TCP是全双工模式。都需要告诉彼此没有数据发送并且都需要得到回复。四次挥手TIME_WAIT保持2MSL(最大报文段生存时间)原因，主要是防止最后一个ack丢失。
>
> [Link](https://github.com/jawil/blog/issues/14)

##### HTTP 连接

> **HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。**从建立连接到关闭连接的过程称为“一次连接”。
>
> > 1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
> >
> > 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。
> >
> > [Link](https://github.com/jawil/blog/issues/14)

##### Socket

> **应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。**
>
> >  包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
> >
> >  套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
> >
> >  [Link](https://github.com/jawil/blog/issues/14) [Confuse](https://www.cnblogs.com/kex1n/p/6501977.html)

##### 七/五层模型

> 七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层；
>
> 五层：物理层，链路层，网络层，传输层，应用层。

#### 设计模式

单例模式：确保一个特定类的一个对象，只能创建一次。创造单例，要确保构造函数私有化, 拷贝构造, 拷贝赋值应该禁用。创建一个静态指针变量来存此单例。示例：[Link](http://www.cnblogs.com/qicosmos/p/3145019.html)。

多例模式：通过 map 存储 key 到 实例的映射。

[写给人看的设计模式](https://pushmind.org/2017/07/31/design-patterns-for-humans/)

##### 设计模式的类型

- 创建型
- 结构型
- 行为型

##### 创建型设计模式

简言之:

> 创建型模式, 是针对如何创建对象的解决方案。简单工厂；工厂方法；抽象工厂；生成器；原型；单例。

1. 简单工厂

> 简单工厂为用户提供了一个实例, 而隐藏了具体的实例化逻辑. 给我造个门

2. 工厂方法

> 一种将实例化逻辑委托给**子类**的方法. 给我造个**铁**门

3. 抽象工厂

> 管理各自独立却又互相依赖的一批工厂（门，匠...）, 而不关心各自的细节. 给我造个**木**门，再给我配个**木**匠。

4. 生成器

> 当创建对象有好多种选项时，导致构造函数的参数列表失控。生成器模式的本质, 就是将构造函数中的参数列表方法化。函数式编程中对该问题的解决方式是: 柯里化, 其本质与生成器模式是一样的。

5. 原型

> 允许你拷贝一份已有对象, 并根据需求改造之。 

6. 单例

> 确保一个特定类的一个对象, 只能创建一次。创造单例, 要确保构造函数私有化, 拷贝构造, 拷贝赋值应该禁用。创建一个静态变量来存此单例。

##### 结构性设计模式

简言之：

> 结构型模式重点关注对象组合, 换句话说, 实体如何互相调用. 

1. 适配器

> 包装一个对象, 让本不兼容其他类的对象变得可兼容。在中间加一层的方式来解决。为了兼容。

2. 桥接

> 优先考虑组合而非继承. 将实现细节从层次结构中, 剥离并独立成另一套层次结构。桥接模式本质上是一种拆分。

3. 组成

> 组合模式让客户以统一的方式对待各个独立的对象。其核心就是多态特性的体现。

4. 装饰

> 装饰模式将对象包装在装饰类对象中, 从而在运行时动态改变该对象的行为。装饰的是对象自身, 且支持重复装饰。

5. 外观

> 外观模式为复杂的子系统提供了一个简单接口。用的依然是”多加一层”的思想, 通过封装的方式来实现。为了封装。

6. 享元

> 通常以最小的存储用量或计算成本为代价, 共享给尽可能多的相似对象。享元模式的本质就是最基本的缓存思想。

7. 代理

> 使用代理模式, 一个类会表现出另一个类的功能。依然体现了加一层的思想。为了增加功能。

##### 行为型设计模式

简言之：

> 关注对象间的责任分配. 它们与结构模式最大的不同在于: 它们不仅仅指定结构, 还概述了结构之间消息传递/通讯的模式. 

1. 责任链

> 它有助于建立一条对象链. 请求会从一端开始, 依次访问对象, 直到找到合适的处理程序. 就像根据付款额选择一串付款方式中的一个。

2. 命令

> 允许你将操作封装在对象中. 这种模式背后的核心思想是分离客户与接收者. 你(客户)用遥控器(调用者)来切换(命令)电视(接收者)节目. 命令模式本质上, 是对消息协议的一种抽象, 而用的手法是回调。 提出要求的是客户, 执行要求的是厨师, 而连接两者的是服务员, 但真正连接者是消息的接口, 这个就是命令. 

1. 迭代器

> 它呈现了一种访问对象元素, 却不暴露底层方法的方式.

1. 中介者

> 中介者模式增加了一个第三方对象(中介者)来控制两个对象(同事)间的交互. 有助于对彼此通信的解耦, 毕竟他们并不需要关心对方的实现细节.

1. 备忘录

> 备忘录模式会抓取并储存对象的当前状态, 之后可便捷的恢复出来. 就是对缓存这个行为的对象化. 

1. 观察者

> 定义对象间的依赖关系, 以至于一个对象的状态改变, 依赖它的对象们都会收到通知. 被称为发布-订阅模式. 但无论叫什么, 其实本质都是注入+回调. 

1. 访问者

> 访问者模式允许你为对象们增加更多的操作, 却不必修改它们. 其实本质依然是注入-回调模式. 想用一个统一的接口, 去迭代的调用这些不同的方法，是一种对调用的抽象。

1. 策略

> 策略模式允许你根据实际情况切换算法或策略. 本质依然是注入+多态

1. 状态

> 它让你在状态改变的同时, 也改变类的行为。例如, 你选择了加粗, 后续的字都会是粗的, 同样的, 选择了斜体, 后续都会是斜体. 本质依然是注入+多态。

1. 模板方法

> 模板方法定义了如何执行某种算法的框架, 但将具体实现延迟到子类. 模板方法基本就是多态的集中体现. 只不过将所有多态方法集中到一个公共接口中. 