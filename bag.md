### 背包问题九讲

[参考 Link](https://www.kancloud.cn/kancloud/pack/70125)

------

#### 1. 01 背包

特点：每种物品仅有一件，可以选择放或不放。

假设：设有 N 件物品，一个容量为 V 的背包，第 i 件物品的费用是 c[i] ，价值是 w[i] 。

##### 基本思路

用子问题定义状态：即 `f[i][v]` 表示前 i 件物品 (可放可不放) 放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是： 

$f[i][v]=max\{f[i-1][v],f[i-1][v-c[i]]+w[i]\} $

两项分别对应第 i 件物品不放入，和第 i 间物品放入的情况。

##### 优化空间复杂度

以上方法的时间和空间复杂度均为 O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到 O(V) 。 

在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态 $f[i-1][v-c[i]]$ 的值。 

```c
for i=1..N
    for v=V..0
        f[v]=max{f[v],f[v-c[i]]+w[i]};
```

```
处理一件
procedure ZeroOnePack(cost,weight)
    for v=V..cost
        f[v]=max{f[v],f[v-cost]+weight}
```

##### 要求装满背包

要求恰好装满背包，那么在初始化时除了 f[0] 为 0 其它 f[1..V] 均设为 -∞ ，这样就可以保证最终得到的 f[V] 是一种恰好装满背包的最优解。**从只有 1 件物品考虑就能理解。**

如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 f[0..V] 全部设为 0 。 

------

#### 2. 完全背包

特点：每种物品有无限件可用。

##### 基本思路

与 01 背包类似，每种物品的策略从取或不取两种，变为取0件、取1件、取2件……等多种。 状态方程可写为，对应所有策略的最优值：

$f[i][v]=max\{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v\} $

求解状态f[i][v]的时间是 O(v/c[i]) ，总的复杂度可以认为是 O(V*Σ(V/c[i])) 。

##### 简答的优化

首先将费用大于V的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个 。

##### 转换为 01 背包

最简单的想法是，考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个 01 背包问题。 

更高效的转化方法是：把第i种物品拆成费用为c[i]*2^k、价值为w[i]*2^k的若干件物品，其中k满足`c[i]*2^k<=V`。这是二进制的思想 。把每种物品拆成 O(log V/c[i]) 件物品 。

**O(VN) 算法**：状态转移方程：$f[i][v]=max\{f[i-1][v],f[i][v-c[i]]+w[i]\} $

```c
for i=1..N
    for v=0..V
        f[v]=max{f[v],f[v-cost]+weight}
```

```c
处理一件
procedure CompletePack(cost,weight)
    for v=cost..V
        f[v]=max{f[v],f[v-c[i]]+w[i]}
```

------

#### 3. 多重背包问题

特点：第 i 种物品最多有 n[i] 件可用 。

##### 基本算法

与完全背包问题类似，复杂度是O(V*Σn[i]) ：

$f[i][v]=max\{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]\} $

##### 转换为 01 背包

把第 i 种物品换成 n[i] 件 01 背包中的物品，则得到了物品数为 Σn[i] 的 01 背包问题 ，复杂度仍然是 O(V*Σn[i]) 。

仍然考虑二进制的思想，1,2,4,...,2^(k-1),n[i]-2^k+1 ：如果 n[i] 为 13，就将这种物品分成系数分别为 1,2,4,6 的四件物品，复杂度为 O(V*Σlog n[i]) 。 

```c
处理一件：
procedure MultiplePack(cost,weight,amount)
    if cost*amount>=V
        CompletePack(cost,weight)
        return
    integer k=1
    while k<amount
        ZeroOnePack(k*cost,k*weight)
        amount=amount-k
        k=k*2
    ZeroOnePack(amount*cost,amount*weight)
```

有 O(VN) 算法

------

#### 4. 混合三种背包问题

特点：有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包） 。

##### 01 背包与完全背包混合

```c
for i=1..N
    if 第i件物品属于01背包
        for v=V..0
            f[v]=max{f[v],f[v-c[i]]+w[i]};
    else if 第i件物品属于完全背包
        for v=0..V
            f[v]=max{f[v],f[v-c[i]]+w[i]};
```

##### 加上多重背包

```c
for i=1..N
    if 第i件物品属于01背包
        ZeroOnePack(c[i],w[i])
    else if 第i件物品属于完全背包
        CompletePack(c[i],w[i])
    else if 第i件物品属于多重背包
        MultiplePack(c[i],w[i],n[i])
```

------

#### 5. 二维费用背包

特点：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。 

##### 基本思路

费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是： 

$f[i][v][u]=max\{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]\} $

如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量 v 和 u 采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。 

##### 物体总个数的限制

有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。 

------

#### 6. 分组的背包问题

特点：在 01 背包的基础上，给予限制：这些物品被划分为若干组，每组中的物品互相冲突，**最多选一件**。 

##### 基本思路

这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。 设 $f[k][v]$ 表示**前 k 组**物品花费费用 v 能取得的最大权值 

$f[k][v]=max\{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于组k\} $

```c
使用一维数组：
for 所有的组k
    for v=V..0
        for 所有的i属于组k
            f[v]=max{f[v],f[v-c[i]]+w[i]}
```

“for v=V..0” 这一层循环必须在 “for 所有的i属于组k” 之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。 

------

#### 7. 有依赖的背包问题

特点：物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 

##### 基本思路

查看[参考 Link](https://www.kancloud.cn/kancloud/pack/70131)

------

#### 8. 泛化物品

特点：泛化物品没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。 例如一个物品分配给它的费用为 v 时，能得到的价值就是 h(v) 。

01 背包，完全背包和多重背包都可以看成泛化物品。一个物品组也可以看出一个泛化物品。

##### 泛化物品的和

面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢 ？对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。 

$f(v)=max\{h(k)+l(v-k)|0<=k<=v\} $

也就是说， f 是一个由泛化物品h和l决定的泛化物品。 事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。 

------

#### 9. 背包问题问法的变化

##### max-min

求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。 

如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。 

#### 输出方案

如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。 

##### 01 背包

以01背包为例，方程为`f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}`。再用一个数组`g[i][v]`，设`g[i][v]=0` 表示推出`f[i][v]` 的值时是采用了方程的前一项（也即`f[i][v]=f[i-1][v]`），`g[i][v]=1`表示采用了方程的后一项`f[i-1][v-c[i]]+w[i]`。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。 

```c
i=N
v=V
while(i>0)
    if(g[i][v]==0)
        print "未选第i项物品"
    else if(g[i][v]==1)
        print "选了第i项物品"
        v=v-c[i]
	i--
```

也可以在输出方案的过程中根据f[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的`g[i][v]==0` 改成`f[i][v]==f[i-1][v]`，`g[i][v]==1`改成`f[i][v]==f[i-1][v-c[i]]+w[i]`也可。 

##### 输出字典序最小的最优方案

我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。 

或者先把物品逆序排列一下， 可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从N到1输入时，如果`f[i][v]==f[i-1][i-v]`及`f[i][v]==f[i-1][f-c[i]]+w[i]`同时成立，应该按照后者（即选择了物品 i ）来输出方案。 

##### 求方案总数

还可以得到装满背包或将背包装至某一指定容量的方案总数。 

对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是完全背包中的物品，转移方程即为

$f[i][v]=sum\{f[i-1][v],f[i][v-c[i]]\}$

初始条件`f[0][0]=1`。

事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。

##### 最优方案总数

结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：`f[i][v]`意义同前述，`g[i][v]`表示这个子问题的最优方案的总数，则在求`f[i][v]`的同时求`g[i][v]`的伪代码如下： 

```c
01 背包
初始化G[][]为1
for i=1..N
   for v=0..V
        f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
        g[i][v]=0
        if(f[i][v]==f[i-1][v])
            g[i][v] += g[i-1][v]
        if(f[i][v]==f[i-1][v-c[i]]+w[i])
            g[i][v] += g[i-1][v-c[i]]
```

##### 求次优解、第 k 优解

查看 [参考 Link](https://www.kancloud.cn/kancloud/pack/70133)

#### 背包问题的搜索解法

##### 简单的深搜

枚举出所有2^N种将物品放入背包的方案，然后找最优解。 

```c
procedure SearchPack(i,cur_v,cur_w)
    if(i>N)
        if(cur_w>best)
            best=cur_w
        return
    if(cur_v+v[i]<=V)
        SearchPack(i+1,cur_v+v[i],cur_w+w[i])
    SearchPack(i+1,cur_v,cur_w)
```

其中cur_v和cur_w表示当前解的费用和权值。主程序中调用SearchPack(1,0,0)即可。 

##### 搜索的剪枝

基本的剪枝方法不外乎可行性剪枝或最优性剪枝。

可行性剪枝即判断按照当前的搜索路径搜下去能否找到一个可行解，例如：若将剩下所有物品都放入背包仍然无法将背包充满（设题目要求必须将背包充满），则剪枝。

最优性剪枝即判断按照当前的搜索路径搜下去能否找到一个最优解，例如：若加上剩下所有物品的权值也无法得到比当前得到的最优解更优的解，则剪枝。

##### 搜索的顺序

在搜索中，可以认为顺序靠前的物品会被优先考虑。所以利用贪心的思想，将更有可能出现在结果中的物品的顺序提前，可以较快地得出贪心地较优解，更有利于最优性剪枝。所以，可以考虑将按照“性价比”（权值/费用）来排列搜索顺序。

另一方面，若将费用较大的物品排列在前面，可以较快地填满背包，有利于可行性剪枝。

最后一种可以考虑的方案是：在开始搜索前将输入文件中给定的物品的顺序随机打乱。这样可以避免命题人故意设置的陷阱。

##### 搜索还是 DP

如果一个背包问题可以用DP解，V一定不能很大，否则O(VN)的算法无法承受，而一般的搜索解法都是仅与N有关，与V无关的。所以，V很大时（例如上百万），命题人的意图就应该是考察搜索。另一方面，N较大时（例如上百），命题人的意图就很有可能是考察动态规划了。

另外，当想不出合适的动态规划算法时，就只能用搜索了。例如看到一个从未见过的背包中物品的限制条件，无法想出DP的方程，只好写搜索以谋求一定的分数了。

