#### C++ 特性

- map 与 unordered_map 的区别

  > map: #include < map >
  >
  > unordered_map: #include < unordered_map >
  >
  > - map： map 内部实现了一个红黑树，该结构具有自动排序的功能，因此 map 内部的所有元素都是**有序的**，map 的很多操作在 $O(logn)$ 的时间复杂度下就可以实现。
  > - unordered_map: unordered_map 内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。
  > - 对于那些有顺序要求的问题，用 map 会更高效一些；对于查找问题，unordered_map 会更加高效一些。
  > - 使用非内置类型作为 key，要使用 map ，需要重载 operator < ，而要使用 unordered_map 需要重载 operator == 。

- 面向对象的了解

##### 面向对象的了解

> 面向对象编程注重的是：**1）数据和其行为的打包封装，2）程序的接口和实现的解耦**。[Link](https://coolshell.cn/articles/8745.html)

> 面向对象是相对于面向过程而言的。面向过程语言是一种基于**功能分析**的、以**算法**为中心的程序设计方法；而面向对象是一种基于**结构分析**的、以**数据**为中心的程序设计思想。
>
> >  从面向过程的角度看，类就是一个特殊的数据结构，它就好像是我们C语言中的结构体;从面向对象的角度看，类就是具有相同属性和方法的对象的集合。
> >
> >  面向对象有三大特性：封装、继承、多态。
> >
> > - **封装，**就是指隐藏对象的实现细节，给外界提供公共的方法来访问。
> >
> > - **继承**，子类可以继承父类的公共属性和方法，子类永远没法继承到父类的私有属性和方法。
> > - **多态，**就是同一个实现接口，对不同的实例而执行不同的操作。
> >
> >  [Link](https://my.oschina.net/shaw1688/blog/601142)

##### 多态实现原理

> 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。
>
> >  C++的多态性是通过动态绑定技术来实现的。
> >
> >  [Link](http://blog.csdn.net/tujiaw/article/details/6753498)

> 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。
>
> >  多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。
> >
> >  [Link](https://www.jianshu.com/p/3a404ab34936) [Link](https://blog.csdn.net/lihao21/article/details/50688337)

##### C 语言实现多态

  使用函数指针，以及函数指针的字节对齐实现多态，使得将子类指针赋予父类指针，调用函数时能正常调用。

  [Link](http://www.cnblogs.com/wuyudong/p/achieving-polymorphism-in-c.html)

##### 多态

> 多态性的表现，这里用c++来简述，其实OOP应该都差不多。
>
> >  c++的多态分为两种：
> >
> >  1.编译时多态：重载，函数名称相同，但参数类型或参数个数不同的一组函数。在编译期就决好的。
> >
> >  2.运行时多态：重写（也称为覆盖override），也称为覆盖，牵扯到虚函数，简单来说就是虚函数（impure virtual）为我们实现一份默认的操作，我们可以使用这个也可以自己重写（覆盖）虚函数。

##### 右值引用与转移语义

> 右值引用 (Rvalue Referene) 是 C++ 新标准 (C++11, 11 代表 2011 年 ) 中引入的新特性 , 它实现了转移语义 (Move Sementics) 和精确传递 (Perfect Forwarding)。它的主要目的有两个方面：
>
> > 1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
> > 2. 能够更简洁明确地定义泛型函数。
> >
> >  在 C++11 之前，右值是不能被引用的，最大限度就是用常量引用绑定一个右值

> - 通俗的左值的定义就是非临时对象，右值是指临时的对象，它们只在当前的语句中有效。
>
> > - 实际上右值是可以被修改的，既然右值可以被修改，那么就可以实现右值引用。
> > - 左值的声明符号为”&”， 为了和左值区分，右值的声明符号为”&&”。

> 右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。
>
> > - 参数（右值）的符号必须是右值引用符号，即“&&”。
> > - 参数（右值）不可以是常量，因为我们需要修改右值。
> > - 参数（右值）的资源链接和标记必须修改。否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了。

> 标准库提供了函数 std::move，这个函数以非常简单的方式将左值引用转换为右值引用。
>
> >  `std::move`在提高 swap 函数的的性能上非常有帮助。通过 std::move，一个简单的 swap 函数就避免了 3 次不必要的拷贝操作。

> 精确传递适用于这样的场景：需要将一组参数原封不动的传递给另一个函数。
>
> > - 函数 forward_value 为每一个参数必须重载两种类型，T& 和 const T&，否则，下面四种不同类型参数的调用中就不能同时满足
> > - 右值引用，只需要定义一次，接受一个右值引用的参数，就能够将所有的参数类型原封不动的传递给目标函数。

  [Link](https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html)

##### std::vector 的容量增长

> std::vector在插入新元素时，若遇到已分配容量不足的情况，会自动拓展容量大小，而这个拓展容量的过程为：

- 开辟另外一块更大的内存空间，该空间大小通常为原空间大小的两倍；
- 将原内存空间中的数据拷贝到新开辟的内存空间中；
  - 析构原内存空间的数据，释放原内存空间，并调整各种指针指向新内存空间。

> Windows下的std::vector一般会按原有容量的1.5倍来增长，到了后期内存吃紧的时候或者一次性插入的数据个数多于原有数据的时候会改变策略为增长空间为刚好能容纳原有数据和新增数据。

> 对于push_*这样的操作，__n为1，一般会小于size()，所以这时候表现出来的就是翻倍增长，假如是一次插入很多个的时候，__n就有可能比size()大了，这时候也打破翻倍增长的规律，改为增长为刚好容纳原有数据和新增数据的容量了。

  [Link](https://lgcagithub.github.io/2016/08/20/cpp-std-vector-grow/)

##### 只知道数组名，求数组长度

- 在数组的作用域中，使用`sizeof(数组名)/sizeof(数组的一个元素)`

- `strlen`可以得到字符数组的长度，但遇到`'\0'`就截止，得到结果后应加 1 。

  - 将数组名作为参数传递，将被当作指针类型，因此需要额外的方法来传递长度信息。

  [Link](http://www.cjjjs.com/paper/bcyy/2016317114754540.html)

##### 结构体的位置偏移

- 结构体中的所有成员其首地址偏移量必须为**其数据类型长度的整数倍**，其中第一个成员的首地址偏移量为0 。例如，若第二个成员类型为 int ，则其首地址偏移量必须为 4 的倍数，否则就要“首部填充”；以此类推。

- 结构体所占的总字节数即 sizeof() 函数返回的值必须是**最大成员的长度的整数倍**，否则要进行“末尾填充”；

  - 若结构体 A 将结构体 B 作为其成员，则结构体 B 存储的首地址的偏移量必须为 **B 中所含成员数据长度最大值的整数倍**，如若 B 中成员为 int，double，char，则 B 的偏移量要为 8 的整数倍；否则进行“中间填充”。
  - 空类的长度为 1 ;否则 class 和 struct 的数据对齐原则一致。
  - sizeof() 计算时只计算存放在栈中的空间，static 等声明的全局变量存放在静态数据空间，不会计算在内。

  [Link](https://blog.csdn.net/a1154761720/article/details/19816615)

##### inline 函数

- inline 函数定义和声明通常全部放在头文件中，因为inline函数会在编译阶段被替换为函数代码，不用到 call/return 机制，如果在一个 .c 中定义内联函数，则在其他文件中无法用该函数；

- 宏在编译前处理（编译预处理阶段），inline 在编译阶段处理；

  - inline 函数和宏的区别在于 inline 函数在替换时会进行类型检查，而且 inline 函数的声明对于编译器而言只是建议性的，编译器会自身优化；
  - 虚函数肯定不会是内联函数，虚函数是在运行时决定调用哪个函数，而内联函数在编译阶段就会被替换为代码块，函数名符号根本就不存在了；
  - 内联函数的主要作用在于节约了资源，消除了一个call/return机制；

  [Link](https://blog.csdn.net/a1154761720/article/details/19816615)

##### 内存拷贝

  void *memcpy(void *dest, const void *src, size_t n);   #include<string.h>

  void *memmove(void *dest, const void *src, size_t n);   #include<string.h>

- 当源地址位于 dest~dest+n 之内时，直接从头开始复制会更改原数据的部分内容。

- 当目的地址位于 src~src+n 之内时，直接从头开始复制会覆盖部分原数据，即更改了原数据内容，复制结果也不正确。可以从尾部开始复制，保证复制结果正确，但原数据仍然会被覆盖。

  - memcpy 不考虑内存覆盖，memmove 考虑内存覆盖，会从尾部开始复制。

  [Link](http://jeremybai.github.io/blog/2014/09/05/memcpy)

##### 静态函数/变量

- 静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。如果不加定义就会报错，初始化是赋一个初始值，而定义是分配内存。

- 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

  - 可以使用静态成员变量清楚了解构造与析构函数的调用情况。

  [Link](http://www.runoob.com/cplusplus/cpp-static-members.html)

##### C 可变参数

  函数参数的传递存储在栈中,从右至左压入栈中,压栈过程为递减 

  `int func(int, ... ) {}`

```c
  #include <stdarg.h>
  double average(int num,...)
  {
      va_list valist;
      /* 为 num 个参数初始化 valist */
      va_start(valist, num);
      /* 访问所有赋给 valist 的参数 */
      for (i = 0; i < num; i++)
      {
         sum += va_arg(valist, int);
      }
      /* 清理为 valist 保留的内存 */
      va_end(valist);
  }
```

  [Link](http://www.runoob.com/cprogramming/c-variable-arguments.html)

##### malloc/free 和 new/delete 的区别

1. malloc/free 是 C/C++ 语言的标准库函数，new/delete 是 C++ 的运算符；
2. new 能自动分配空间大小
3. new/delete 会调用对象的构造函数/析构函数，malloc/free 仅仅分配/释放内存。
4. new 返回对象指针，malloc 返回 void 指针。

##### printf/cout 执行编译顺序

- printf/cout 从右向左编译，从左向右输出，如 `cout << p << ++p;` 输出两个数值相等。

##### 类变量初始化顺序

- 初始化列表的执行顺序由变量的声明顺序决定。

##### 构造/析构执行顺序

- 先调用父类构造函数，再调用子类构造函数
- 先调用子类析构函数，再调用父类析构函数

#### Python 特性

[Link](https://github.com/taizilongxu/interview_python)

#### Git

##### 分区

> 分为：工作区，版本库，版本库包含暂存区、分支以及分支指针。
>
> >  第一步是用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区；
> >
> >  第二步是用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支。

- fetch 与 pull 的区别

  > - git fetch ：相当于是从远程获取最新版本到本地，不会自动 merge
  > - git pull ：相当于是从远程获取最新版本并 merge 到本地